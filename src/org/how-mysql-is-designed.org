#+TITLE: MySQL是如何设计的
#+DATE: [2021-04-14 Wed 14:15]

*** MySQL
众所周知，MySQL是一个数据库管理系统，它在类别上属于关系型数据库。何为关系型数据库？从字面意思上，我们就可以大概猜到它应该是描述某种关系的数据库，而人类社会本质上是所有关系的总和。从现实世界延伸，人们需要在数字世界去描述这些关系，于是便有了关系型数据库。

首先，我们先来看下 MySQL 服务器的逻辑架构图。
[[file:./images/mysql-architecture.png]]

我们再来看下搜索引擎的架构图
[[file:./images/search-engine-architecture.gif]]

*** 存储引擎
MySQL 支持很多种存储引擎。除了最为大家熟知的MyISAM 和InnoDB，它还支持如下存储引擎。
+ Archive 引擎
+ Blackhole 引擎
+ CSV 引擎
+ Federated 引擎
+ Memory 引擎
+ Merge 引擎
+ NDB 集群引擎
除了上面列出的。它还支持一些第三方存储引擎，这里不再多说。

InnoDB 目前是MySQL的默认事务型引擎，也是使用最广泛的存储引擎。那它有什么特点呢？

首先就是它支持事务，而且性能非常好，更有自动崩溃恢复特性。其次它采用MVCC（多版本并发控制）来支持高并发，并且实现了四个标准的隔离级别。其默认级别是REPEATABLE READ（可重复读），并且通过间隙锁（next-key locking）策略防止幻读出现。另外InnoDB表是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能。

*** 索引构建器

如果词典能够完整地加载到内存，那么所形成的二叉树的搜索效率将会非常高。特别是当二叉树处于平衡状态时，平均进行log2N次查找就能找到单词。

但是，如果词典无法完整地加载到内存，而必须存储到二级存储器上时，二叉树就未必是搞笑的数据结构了。HDD或SSD等二级存储器一般被称作“块设备”，由于它们是以块为单位进行输入输出的，所以即使只是读取块中1个字节的数据，也不得不对整个块进行输入输出操作。例如，假设我们用二叉查找树实现了含有 100 万个单词的词典，那么进行二分查找的话，平均需要 20 次查找，因此在最坏的情况下就需要加载 20 个块。也就是说，假设二级存储的加载性能为 5ms/ 块，那么在 1 次检索中，仅花费在二级存储输入输出上的时间就高达 100ms。


#+BEGIN_QUOTE
“实现词典
在实现词典时，为了能够快速地获取到对应着单词的倒排列表，通常都会使用哈希表、树等数据结构。例如，常用的树形数据结构有保存着各个单词顺序关系的二叉查找树（Binary Search Tree）和字典树（Trie）等。

∎ 用二叉查找树实现词典
使用二叉查找树实现词典时，要先将数据对（的列表）按照单词的词典顺序排列，然后存储到存储器中。数据对是由单词和对应着该单词的倒排列表的引用信息构成的。例如，若用内存上的二叉查找树实现之前例子中的词典，就会得到如图 1-3 所示的树形结构。树中的各个结点是通过地址引用（指针）连接起来的。



图 1-3　在内存上实现词典（使用二叉查找树）

“同样地，在二级存储上实现词典时，也要先将数据对按照单词的词典顺序排列，然后一个接一个地存储到存储器上。但是，如果只是单纯地一个接一个地存储，就无法知道各数据对应该在哪里结束了，因此在此之上还要维护一个列表，用于存储从开头算起每个数据对的偏移量。对应的数据结构如图 1-4 所示。在进行检索时，可以对该偏移量的列表进行二分查找。

”

“图 1-4　在二级存储器上实现词典（使用二叉查找树）

如果词典能够完整地加载到内存，那么所形成的二叉树的搜索效率将会非常高。特别是当二叉树处于平衡状态时，平均进行 log2 N 次查找就能找到单词。

但是，如果词典无法完整地加载到内存，而必须存储到二级存储器上时，二叉树就未必是高效的数据结构了。HDD 或 SSD 等二级存储器一般被称作“块设备”，由于它们是以块为单位进行输入输出的 5 ，所以即使只是读取块中 1 个字节的数据，也不得不对整个块进行输入输出操作。例如，假设我们用二叉查找树实现了含有 100 万个单词的词典，那么进行二分查找的话，平均需要 20 次查找，因此在最坏的情况下就需要加载 20 个块。也就是说，假设二级存储的加载性能为 5ms/ 块，那么在 1 次检索中，仅花费在二级存储输入输出上的时间就高达 100ms。

“5 HDD 的最小输入输出单位是 512 字节的扇区。文件系统通常以页为单位来管理存储空间（空间大小是设备块大小的常数倍），并以页为单位进行输入输出。Linux 通常以 4KB 为一页。”

“因此，当要存储大型词典时，往往要使用适合块设备的 B+ 树等树形数据结构。”

“用 B+ 树实现词典
B+ 树是一种平衡的多叉树，属于从 B 树派生出来的树形结构。在 B+ 树中，所有的记录都存储在树中的叶结点（Leaf Node）上，内部结点（Internal Node）上只以关键字的顺序存储关键字 6 。B+ 树的示意图如 图 1-5 所示。”

“B+ 树通常以文件系统中页尺寸的常数倍为单位管理各结点，而由这样的结点来构成树，则有助于减少检索时对二级存储的输入输出次数（详细内容请参考书后的参考文献 1）。

下面就让我们用 B+ 树来实现之前的包含了 100 万个单词的词典吧。假设有以下设定。

块大小：4KB

页大小：4KB

单词的平均大小：10 字节

页内偏移量的大小：2 字节 7

指向下一级结点的指针的大小：4 字节”

“由于单词的长度不是固定的，所以为了指示出每个单词在页中的保存位置，通常还要维护一个偏移量的数组。”

“基于这种假设，可以算出每个单词将占用页中 16 个字节的空间，因此每页中可以存放大约 250 个关键词（单词）8 。由于页中的每个单词都持有一个指向下级结点的指针，下级结点中存储的是按照词典顺序排”

“在该单词之前（后）的单词集合，所以可以推算出要存储 100 万个单词只需要 3 层结点就足够了（100 万＜ 250× 250×250 ＝约 1500 万）。也就是说，只要从二级存储中读取 3 个结点，就可以检索到任意的单词了。假设二级存储的加载性能还是 5ms/ 块，那么花在检索上的输入输出时间就是 15ms，这与花费在二叉查找树检索上的 100ms 的输入输出时间形成了鲜明的对比。”

“为了估算输入输出的次数，这里仅进行了非常粗略地计算。实际上每一页中还包含着用于管理该页信息的头部，而且如果一页中有 N 个单词的话，就还会有 N ＋ 1 个指针。”






#+END_QUOTE









*** 为什么MySQL(InnoDB)会使用B+ tree，而非哈希表或树等数据结构。





+ https://draveness.me/whys-the-design-mysql-b-plus-tree/
